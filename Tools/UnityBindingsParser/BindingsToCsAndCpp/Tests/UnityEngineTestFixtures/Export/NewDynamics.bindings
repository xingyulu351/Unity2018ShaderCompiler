C++RAW


#include "UnityPrefix.h"
#include "Configuration/UnityConfigure.h"

#include "Runtime/Graphics/Transform.h"
#include "Runtime/Dynamics/Rigidbody.h"
#include "Runtime/Geometry/Ray.h"
#include "Runtime/Dynamics/PhysicsManager.h"
#include "Runtime/Geometry/Sphere.h"
#include "Runtime/Dynamics/Joints.h"
#include "Runtime/Dynamics/ConstantForce.h"
#include "Runtime/Graphics/Heightmap.h"

#include "Runtime/Dynamics/CapsuleCollider.h"
#include "Runtime/Dynamics/BoxCollider.h"
#include "Runtime/Dynamics/SphereCollider.h"
#include "Runtime/Dynamics/RaycastCollider.h"
#include "Runtime/Dynamics/WheelCollider.h"
#include "Runtime/Dynamics/MeshCollider.h"
#include "Runtime/Dynamics/PhysicMaterial.h"
#include "Runtime/Dynamics/CharacterController.h"
#include "Runtime/Dynamics/CharacterJoint.h"
#include "Runtime/Dynamics/ConfigurableJoint.h"
#include "Runtime/Dynamics/SpringJoint.h"
#include "Runtime/Geometry/AABB.h"
#include "Runtime/Filters/Mesh/LodMesh.h"
#include "Runtime/Dynamics/Cloth.h"
#include "Runtime/Misc/GameObjectUtility.h"
#include "Runtime/Dynamics/SkinnedCloth.h"
#include "Runtime/Filters/Misc/ClothRenderer.h"
#include "Runtime/Dynamics/RaycastHit.h"
#include "Runtime/Mono/MonoBehaviour.h"
#include "Runtime/Mono/MonoManager.h"
#include "Runtime/Scripting/ScriptingUtility.h"
#include "Runtime/Scripting/ScriptingExportUtility.h"

using namespace Unity;

#define out




CSRAW
#if ENABLE_PHYSICS
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Collections;

#pragma warning disable 649

namespace UnityEngine
{

// Option for how to apply a force using Rigidbody.AddForce.
ENUM ForceMode
	
	// Add a continuous force to the rigidbody, using its mass.
	Force = 0,
	
	// Add a continuous acceleration to the rigidbody, ignoring its mass.
	Acceleration = 5,
	
	// Add an instant force impulse to the rigidbody, using its mass.
	Impulse = 1,
	
	// Add an instant velocity change to the rigidbody, ignoring its mass.
	VelocityChange = 2,
END

// Global physics properties and helper methods.
CONDITIONAL ENABLE_PHYSICS
NONSEALED_CLASS Physics
	
	// The gravity applied to all rigid bodies in the scene.
	THREAD_AND_SERIALIZATION_SAFE
	CUSTOM_PROP static Vector3 gravity { return GetPhysicsManager ().GetGravity (); } { return GetPhysicsManager ().SetGravity (value); }
	
	
	// The minimum contact penetration value in order to apply a penalty force (default 0.05). Must be positive.
	CUSTOM_PROP static float minPenetrationForPenalty { return GetPhysicsManager ().GetMinPenetrationForPenalty (); } { return GetPhysicsManager ().SetMinPenetrationForPenalty (value); }

	// Two colliding objects with a relative velocity below this will not bounce (default 2). Must be positive.
	CUSTOM_PROP static float bounceThreshold { return GetPhysicsManager ().GetBounceThreshold (); } { return GetPhysicsManager ().SetBounceThreshold (value); }

	OBSOLETE warning Please use bounceThreshold instead.
	CSRAW static public  float bounceTreshold { get { return bounceThreshold; } set { bounceThreshold = value; }  }

	// The default linear velocity, below which objects start going to sleep (default 0.15). Must be positive.
	CUSTOM_PROP static float sleepVelocity { return GetPhysicsManager ().GetSleepVelocity (); } { return GetPhysicsManager ().SetSleepVelocity (value); }

	// The default angular velocity, below which objects start sleeping (default 0.14). Must be positive.
	CUSTOM_PROP static float sleepAngularVelocity { return GetPhysicsManager ().GetSleepAngularVelocity (); } { return GetPhysicsManager ().SetSleepAngularVelocity (value); }

	// The default maximimum angular velocity permitted for any rigid bodies (default 7). Must be positive.
	CUSTOM_PROP static float maxAngularVelocity { return GetPhysicsManager ().GetMaxAngularVelocity (); } { return GetPhysicsManager ().SetMaxAngularVelocity (value); }

	// The default solver iteration count permitted for any rigid bodies (default 7). Must be positive.
	CUSTOM_PROP static int solverIterationCount { return GetPhysicsManager ().GetSolverIterationCount (); } { return GetPhysicsManager ().SetSolverIterationCount (value); }
	
	CUSTOM private static bool Internal_Raycast (Vector3 origin, Vector3 direction, out RaycastHit hitInfo, float distance, int layermask)
	{
		hitInfo->collider = NULL;

		float dirLength = Magnitude (direction);
		if (dirLength > Vector3f::epsilon)
		{
			Vector3f normalizedDirection = direction / dirLength;
			Ray ray (origin, normalizedDirection);
			
			bool didHit = GetPhysicsManager ().Raycast (ray, distance, *hitInfo, layermask);
			
			if (didHit)
			{
				hitInfo->collider = reinterpret_cast<Collider*>(ScriptingGetObjectReference (hitInfo->collider));
				return true;
			}
			else
			{
				return false;
			}
		}
		else
			return false;
	}

	CUSTOM private static bool Internal_CapsuleCast (Vector3 point1, Vector3 point2, float radius, Vector3 direction, out RaycastHit hitInfo, float distance, int layermask)
	{
		hitInfo->collider = NULL;

		float dirLength = Magnitude (direction);
		if (dirLength > Vector3f::epsilon)
		{
			Vector3f normalizedDirection = direction / dirLength;
			
			bool didHit = GetPhysicsManager ().CapsuleCast (point1, point2, radius, normalizedDirection, distance, *hitInfo, layermask);
			
			if (didHit)
			{
				hitInfo->collider = reinterpret_cast<Collider*>(ScriptingGetObjectReference (hitInfo->collider));
				return true;
			}
			else
			{
				return false;
			}
		}
		else
			return false;
	}

	CUSTOM private static bool Internal_RaycastTest (Vector3 origin, Vector3 direction, float distance, int layermask)
	{
		float dirLength = Magnitude (direction);
		if (dirLength > Vector3f::epsilon)
		{
			Vector3f normalizedDirection = direction / dirLength;
			Ray ray (origin, normalizedDirection);
			return GetPhysicsManager ().RaycastTest (ray, distance, layermask);
		}
		else
			return false;
	}

	// Casts a ray against all colliders in the scene.
	CSRAW static public bool Raycast (Vector3 origin, Vector3 direction, float distance = Mathf.Infinity, int layerMask = kDefaultRaycastLayers)
	{
		return Internal_RaycastTest (origin, direction, distance, layerMask);
	}
	
	// Casts a ray against all colliders in the scene and returns detailed information on what was hit.
	CSRAW static public bool Raycast (Vector3 origin, Vector3 direction, out RaycastHit hitInfo, float distance = Mathf.Infinity, int layerMask = kDefaultRaycastLayers)
	{
		return Internal_Raycast (origin, direction, out hitInfo, distance, layerMask);
	}

	// Same as above using /ray.origin/ and /ray.direction/ instead of /origin/ and /direction/.
	CSRAW static public bool Raycast (Ray ray, float distance = Mathf.Infinity, int layerMask = kDefaultRaycastLayers)
	{
		return Raycast (ray.origin, ray.direction, distance, layerMask);
	}

	// Same as above using /ray.origin/ and /ray.direction/ instead of /origin/ and /direction/.
	CSRAW static public bool Raycast (Ray ray, out RaycastHit hitInfo, float distance = Mathf.Infinity, int layerMask = kDefaultRaycastLayers)
	{
		return Raycast (ray.origin, ray.direction, out hitInfo, distance, layerMask);
	}

	/// *listonly*
	CSRAW static public RaycastHit[] RaycastAll (Ray ray, float distance = Mathf.Infinity, int layerMask = kDefaultRaycastLayers)
	{
		return RaycastAll (ray.origin, ray.direction, distance, layerMask);
	}

	// Casts a ray through the scene and returns all hits. Note that order is not guaranteed. 
	CUSTOM static RaycastHit[] RaycastAll (Vector3 origin, Vector3 direction, float distance = Mathf.Infinity, int layermask = kDefaultRaycastLayers)
	{
		float dirLength = Magnitude (direction);
		if (dirLength > Vector3f::epsilon)
		{
			Vector3f normalizedDirection = direction / dirLength;
			Ray ray (origin, normalizedDirection);

			const PhysicsManager::RaycastHits& hits = GetPhysicsManager ().RaycastAll (ray, distance, layermask);

			return ConvertNativeRaycastHitsToManaged(hits);
		}
		else
		{
			return CreateEmptyStructArray(GetMonoManager().GetCommonClasses().raycastHit);
		}
	}	
	
	// Returns true if there is any collider intersecting the line between /start/ and /end/.
	CSRAW static public bool Linecast (Vector3 start, Vector3 end, int layerMask = kDefaultRaycastLayers)
	{
		Vector3 dir = end - start;
		return Raycast (start, dir, dir.magnitude, layerMask);
	}

	// Returns true if there is any collider intersecting the line between /start/ and /end/.
	CSRAW static public bool Linecast (Vector3 start, Vector3 end, out RaycastHit hitInfo, int layerMask = kDefaultRaycastLayers)
	{
		Vector3 dir = end - start;
		return Raycast (start, dir, out hitInfo, dir.magnitude, layerMask);
	}
	
	// Returns an array with all colliders touching or inside the sphere.
	CUSTOM static Collider[] OverlapSphere (Vector3 position, float radius, int layerMask = kAllLayers)
	{
		const vector<Collider*>& colliders = GetPhysicsManager ().OverlapSphere (position, radius, layerMask);
		
		return CreateScriptingArrayFromUnityObjects(colliders, ScriptingClassFor(Collider));
	}
	/// *listonly*
	CSRAW static public bool CapsuleCast (Vector3 point1, Vector3 point2, float radius, Vector3 direction, float distance = Mathf.Infinity, int layerMask = kDefaultRaycastLayers)
	{
		RaycastHit hitInfo;
		return Internal_CapsuleCast (point1, point2, radius, direction, out hitInfo, distance, layerMask);
	}
	// Casts a capsule against all colliders in the scene and returns detailed information on what was hit.
	CSRAW static public bool CapsuleCast (Vector3 point1, Vector3 point2, float radius, Vector3 direction, out RaycastHit hitInfo, float distance = Mathf.Infinity, int layerMask = kDefaultRaycastLayers)
	{
		return Internal_CapsuleCast (point1, point2, radius, direction, out hitInfo, distance, layerMask);
	}

	// Casts a sphere against all colliders in the scene and returns detailed information on what was hit.

	CSRAW static public bool SphereCast (Vector3 origin, float radius, Vector3 direction, out RaycastHit hitInfo, float distance = Mathf.Infinity, int layerMask = kDefaultRaycastLayers)
	{
		return Internal_CapsuleCast (origin, origin, radius, direction, out hitInfo, distance, layerMask);
	}

	/// *listonly*
	CSRAW static public bool SphereCast (Ray ray, float radius, float distance = Mathf.Infinity, int layerMask = kDefaultRaycastLayers)
	{
		RaycastHit hitInfo;
		return Internal_CapsuleCast (ray.origin, ray.origin, radius, ray.direction, out hitInfo, distance, layerMask);
	}	
	// Casts a sphere against all colliders in the scene and returns detailed information on what was hit.

	CSRAW static public bool SphereCast (Ray ray, float radius, out RaycastHit hitInfo, float distance = Mathf.Infinity, int layerMask = kDefaultRaycastLayers)
	{
		return Internal_CapsuleCast (ray.origin, ray.origin, radius, ray.direction, out hitInfo, distance, layerMask);
	}
	

	// Like [[Physics.CapsuleCast]], but this function will return all hits the capsule sweep intersects.
	
	CUSTOM static RaycastHit[] CapsuleCastAll (Vector3 point1, Vector3 point2, float radius, Vector3 direction, float distance = Mathf.Infinity, int layermask = kDefaultRaycastLayers)
	{
		float dirLength = Magnitude (direction);
		if (dirLength > Vector3f::epsilon)
		{
			Vector3f normalizedDirection = direction / dirLength;

			const PhysicsManager::RaycastHits& hits = GetPhysicsManager ().CapsuleCastAll (point1, point2, radius, normalizedDirection, distance, layermask);
		
			return ConvertNativeRaycastHitsToManaged(hits);
		}
		else
		{
			return CreateEmptyStructArray(GetMonoManager().GetCommonClasses().raycastHit);
		}
	}

	// Like [[Physics.SphereCast]], but this function will return all hits the sphere sweep intersects.

	
	CSRAW static public RaycastHit[] SphereCastAll (Vector3 origin, float radius, Vector3 direction, float distance = Mathf.Infinity, int layerMask = kDefaultRaycastLayers)
	{
		return CapsuleCastAll (origin, origin, radius, direction, distance, layerMask);
	}	
	//		@param	ray		The starting point and direction of the ray into which the sphere sweep is cast.
	/// *listonly*
	
	CSRAW static public RaycastHit[] SphereCastAll (Ray ray, float radius, float distance = Mathf.Infinity, int layerMask = kDefaultRaycastLayers)
	{
		return CapsuleCastAll (ray.origin, ray.origin, radius, ray.direction, distance, layerMask);
	}	

	
	// Returns true if there are any colliders overlapping the sphere defined by /position/ and /radius/ in world coordinates.
	CUSTOM static bool CheckSphere (Vector3 position, float radius, int layerMask = kDefaultRaycastLayers)
	{
		return GetPhysicsManager ().SphereTest (position, radius, layerMask);
	}

	// Returns true if there are any colliders overlapping the capsule defined by the axis going from /start/ and /end/ and having /radius/ in world coordinates
	CUSTOM static bool CheckCapsule (Vector3 start, Vector3 end, float radius, int layermask =  kDefaultRaycastLayers)
	{
		return GetPhysicsManager().CapsuleTest(start, end, radius, layermask);
	}

	//*undocumented*
	CSRAW public const int kIgnoreRaycastLayer = 1 << 2;
	//*undocumented*
	CSRAW public const int kDefaultRaycastLayers = ~kIgnoreRaycastLayer;
	//*undocumented*
	CSRAW public const int kAllLayers = ~0;
	
	// *undocumented* DEPRECATED
	OBSOLETE warning penetrationPenaltyForce has no effect.
	CUSTOM_PROP static float penetrationPenaltyForce { return 0; } {  }
	
	
	// Makes the collision detection system ignore all collisions between /collider1/ and /collider2/.
	CUSTOM static void IgnoreCollision (Collider collider1, Collider collider2, bool ignore = true)
	{
		GetPhysicsManager().IgnoreCollision(*collider1, *collider2, ignore);
	}

	// Makes the collision detection system ignore all collisions between any collider in /layer1/ and any collider in /layer2/.
	CUSTOM static void IgnoreLayerCollision (int layer1, int layer2, bool ignore = true)
	{
		GetPhysicsManager().IgnoreCollision(layer1, layer2, ignore);
	}

	// Are collisions between /layer1/ and /layer2/ being ignored?
	CUSTOM static bool GetIgnoreLayerCollision (int layer1, int layer2)
	{
		return GetPhysicsManager().GetIgnoreCollision(layer1, layer2);
	}
	
END

// Use these flags to constrain motion of Rigidbodies.
ENUM RigidbodyConstraints
	// No constraints
	None = 0,
	
	// Freeze motion along the X-axis.
	FreezePositionX = 0x02,

	// Freeze motion along the Y-axis.
	FreezePositionY = 0x04,

	// Freeze motion along the Z-axis.
	FreezePositionZ = 0x08,

	// Freeze rotation along the X-axis.
	FreezeRotationX = 0x10,

	// Freeze rotation along the Y-axis.
	FreezeRotationY = 0x20,

	// Freeze rotation along the Z-axis.
	FreezeRotationZ = 0x40,

	// Freeze motion along all axes.
	FreezePosition = 0x0e,

	// Freeze rotation along all axes.
	FreezeRotation = 0x70,

	// Freeze rotation and motion along all axes.
	FreezeAll = 0x7e,

END

// Control of an object's position through physics simulation.	
CONDITIONAL ENABLE_PHYSICS
CLASS Rigidbody : Component

	// The velocity vector of the rigidbody.
	AUTO_PROP Vector3 velocity GetVelocity SetVelocity
	
	// The angular velocity vector of the rigidbody.
	AUTO_PROP Vector3 angularVelocity GetAngularVelocity SetAngularVelocity
	
	// The drag of the object.
	AUTO_PROP float drag GetDrag SetDrag
	
	// The angular drag of the object.
	AUTO_PROP float angularDrag GetAngularDrag SetAngularDrag
	
	// The mass of the rigidbody.
	AUTO_PROP float mass GetMass SetMass
	
	// Sets the mass based on the attached colliders assuming a constant density.
	AUTO void SetDensity (float density);
	
	// Controls whether gravity affects this rigidbody.
	AUTO_PROP bool useGravity GetUseGravity SetUseGravity
	
	
	// Controls whether physics affects the rigidbody.
	AUTO_PROP bool isKinematic GetIsKinematic SetIsKinematic

	// Controls whether physics will change the rotation of the object.
	AUTO_PROP bool freezeRotation GetFreezeRotation SetFreezeRotation

	// Controls which degrees of freedom are alowed for the simulation of this Rigidbody.
	AUTO_PROP RigidbodyConstraints constraints GetConstraints SetConstraints

	// The Rigidbody's collision detection mode.
	AUTO_PROP CollisionDetectionMode collisionDetectionMode GetCollisionDetectionMode SetCollisionDetectionMode
	
	
	// Adds a force to the rigidbody. As a result the rigidbody will start moving.
	CUSTOM void AddForce (Vector3 force, ForceMode mode = ForceMode.Force) { self->AddForce (force, mode); }

	// Adds a force to the rigidbody.  As a result the rigidbody will start moving.
	CSRAW public void AddForce (float x, float y, float z, ForceMode mode = ForceMode.Force) { AddForce (new Vector3 (x, y, z), mode); }

	// Adds a force to the rigidbody relative to its coordinate system.
	CUSTOM void AddRelativeForce (Vector3 force, ForceMode mode = ForceMode.Force) { self->AddRelativeForce (force, mode); }

	// Adds a force to the rigidbody relative to its coordinate system.
	CSRAW public void AddRelativeForce (float x, float y, float z, ForceMode mode = ForceMode.Force) { AddRelativeForce (new Vector3 (x, y, z), mode); }

	// Adds a torque to the rigidbody.
	CUSTOM void AddTorque (Vector3 torque, ForceMode mode = ForceMode.Force)  { self->AddTorque (torque, mode); }
	
	
	// Adds a torque to the rigidbody.
	CSRAW public void AddTorque (float x, float y, float z, ForceMode mode = ForceMode.Force) { AddTorque (new Vector3 (x, y, z), mode); }

	// Adds a torque to the rigidbody relative to the rigidbodie's own coordinate system.
	CUSTOM void AddRelativeTorque (Vector3 torque, ForceMode mode = ForceMode.Force) { self->AddRelativeTorque (torque, mode); }

	// Adds a torque to the rigidbody relative to the rigidbodie's own coordinate system.
	CSRAW public void AddRelativeTorque (float x, float y, float z, ForceMode mode = ForceMode.Force) { AddRelativeTorque (new Vector3 (x, y, z), mode); }

	// Applies /force/ at /position/. As a result this will apply a torque and force on the object.
	CUSTOM void AddForceAtPosition (Vector3 force, Vector3 position, ForceMode mode = ForceMode.Force) { self->AddForceAtPosition (force, position, mode); }


	// Applies a force to the rigidbody that simulates explosion effects. The explosion force will fall off linearly with distance to the rigidbody.
	CUSTOM void AddExplosionForce(float explosionForce, Vector3 explosionPosition, float explosionRadius, float upwardsModifier = 0.0F, ForceMode mode = ForceMode.Force) { self->AddExplosionForce (explosionForce, explosionPosition, explosionRadius, upwardsModifier, mode); }
	
	// The closest point to the bounding box of the attached colliders.
	CUSTOM Vector3 ClosestPointOnBounds (Vector3 position)
	{
		float dist; Vector3f outpos;
		self->ClosestPointOnBounds(position, outpos, dist);
		return outpos;
	}


	// The velocity relative to the rigidbody at the point /relativePoint/.
	AUTO Vector3 GetRelativePointVelocity (Vector3 relativePoint);

	// The velocity of the rigidbody at the point /worldPoint/ in global space.
	AUTO Vector3 GetPointVelocity (Vector3 worldPoint);


	// The center of mass relative to the transform's origin.
	AUTO_PROP Vector3 centerOfMass GetCenterOfMass SetCenterOfMass

	// The center of mass of the rigidbody in world space (RO).
	AUTO_PROP Vector3 worldCenterOfMass GetWorldCenterOfMass

	// The rotation of the inertia tensor.
	AUTO_PROP Quaternion inertiaTensorRotation GetInertiaTensorRotation SetInertiaTensorRotation

	// The diagonal inertia tensor of mass relative to the center of mass.
	AUTO_PROP Vector3 inertiaTensor GetInertiaTensor SetInertiaTensor

	// Should collision detection be enabled? (By default always enabled)
	AUTO_PROP bool detectCollisions GetDetectCollisions SetDetectCollisions

	// Force cone friction to be used for this rigidbody.	
	AUTO_PROP bool useConeFriction GetUseConeFriction SetUseConeFriction

	// The position of the rigidbody.
	AUTO_PROP Vector3 position GetPosition SetPosition

	// The rotation of the rigdibody. 
	AUTO_PROP Quaternion rotation GetRotation SetRotation

	// Moves the rigidbody to /position/.
	AUTO void MovePosition (Vector3 position);
	
	// Rotates the rigidbody to /rotation/.
	AUTO void MoveRotation (Quaternion rot);

	// Interpolation allows you to smooth out the effect of running physics at a fixed frame rate.
	AUTO_PROP RigidbodyInterpolation interpolation GetInterpolation SetInterpolation
	
	// Forces a rigidbody to sleep at least one frame.
	AUTO void Sleep ();
	
	// Is the rigidbody sleeping?
	AUTO bool IsSleeping ();

	// Forces a rigidbody to wake up.
	AUTO void WakeUp ();

	// Allows you to override the solver iteration count per rigidbody.
	AUTO_PROP int solverIterationCount GetSolverIterationCount SetSolverIterationCount
	
	// The linear velocity, below which objects start going to sleep. (Default 0.14) range { 0, infinity }
	AUTO_PROP float sleepVelocity GetSleepVelocity SetSleepVelocity

	// The angular velocity, below which objects start going to sleep.  (Default 0.14) range { 0, infinity }
	AUTO_PROP float sleepAngularVelocity GetSleepAngularVelocity SetSleepAngularVelocity

	// The maximimum angular velocity of the rigidbody. (Default 7) range { 0, infinity }
	AUTO_PROP float maxAngularVelocity GetMaxAngularVelocity SetMaxAngularVelocity
	
	
	// OnCollisionEnter is called when this collider/rigidbody has begun touching another rigidbody/collider.
	CSNONE void OnCollisionEnter (Collision collisionInfo);

	// OnCollisionEnter is called when this collider/rigidbody has stopped touching another rigidbody/collider.
	CSNONE void OnCollisionExit (Collision collisionInfo);

	// OnCollisionStay is called once per frame for every collider/rigidbody that is touching rigidbody/collider.
	CSNONE void OnCollisionStay (Collision collisionInfo);

	// Tests if a rigidbody would collide with anything, if it was moved through the scene.
	CUSTOM public bool SweepTest (Vector3 direction, out RaycastHit hitInfo, float distance = Mathf.Infinity)
	{
		hitInfo->collider = NULL;

		float dirLength = Magnitude (direction);
		if (dirLength > Vector3f::epsilon)
		{
			Vector3f normalizedDirection = direction / dirLength;
			
			bool didHit = self->SweepTest (normalizedDirection, distance, *hitInfo);
			
			if (didHit)
			{
				hitInfo->collider = reinterpret_cast<Collider*>(ScriptingGetObjectReference (hitInfo->collider));
				return true;
			}
			else
			{
				return false;
			}
		}
		else
			return false;
	}
	// Like [[Rigidbody.SweepTest]], but returns all hits.
	CUSTOM RaycastHit[] SweepTestAll (Vector3 direction, float distance = Mathf.Infinity)
	{
		float dirLength = Magnitude (direction);
		if (dirLength > Vector3f::epsilon)
		{
			Vector3f normalizedDirection = direction / dirLength;

			const PhysicsManager::RaycastHits& hits = self->SweepTestAll (normalizedDirection, distance);
	
			return ConvertNativeRaycastHitsToManaged(hits);
		}
		else
		{
			return CreateScriptingArray<RaycastHit>(NULL, 0, GetMonoManager().GetCommonClasses().raycastHit);
		}
	}
	
	//*undocumented* DEPRECATED
	OBSOLETE warning use Rigidbody.maxAngularVelocity instead.
	CSRAW public void SetMaxAngularVelocity (float a) { maxAngularVelocity = a; }
END

// [[Rigidbody]] interpolation mode.
ENUM RigidbodyInterpolation
	// No Interpolation.
	None = 0,
	
	// Interpolation will always lag a little bit behind but can be smoother than extrapolation.
	Interpolate = 1,

	// Extrapolation will predict the position of the rigidbody based on the current velocity.
	Extrapolate = 2
END

// The JointMotor is used to motorize a joint.
CONDITIONAL ENABLE_PHYSICS
STRUCT JointMotor
	CSRAW private float m_TargetVelocity;
	CSRAW private float m_Force;
	CSRAW private bool  m_FreeSpin;
	
	// The motor will apply a force up to /force/ to achieve /targetVelocity/.
	CSRAW public float targetVelocity { get { return m_TargetVelocity; } set { m_TargetVelocity = value; } }
	
	// The motor will apply a force.
	CSRAW public float force { get { return m_Force; } set { m_Force = value; } }
	
	// If /freeSpin/ is enabled the motor will only accelerate but never slow down.
	CSRAW public bool  freeSpin { get { return m_FreeSpin; } set { m_FreeSpin = value; } }
END

// JointSpring is used add a spring force to [[HingeJoint]] and [[PhysicMaterial]].
CONDITIONAL ENABLE_PHYSICS
STRUCT JointSpring

	// The spring forces used to reach the target position
	CSRAW public float spring;

	// The damper force uses to dampen the spring
	CSRAW public float damper;

	// The target position the joint attempts to reach.
	CSRAW public float targetPosition;
	
// We have to keep those as public variables because of a bug in the C# raycast sample.
END

// JointLimits is used by the [[HingeJoint]] to limit the joints angle.
CONDITIONAL ENABLE_PHYSICS
STRUCT JointLimits
	CSRAW private float m_Min;
	CSRAW private float m_MinBounce;
	CSRAW private float m_MinHardness;
	CSRAW private float m_Max;
	CSRAW private float m_MaxBounce;
	CSRAW private float m_MaxHardness;
	
	// The lower limit of the joint. When the joint angle or position is below it, 
	CSRAW public float min { get { return m_Min; } set { m_Min = value; } }

	// The bounciness of the joint when hitting the lower limit of the joint.
	CSRAW public float minBounce { get { return m_MinBounce; } set { m_MinBounce = value; } }

	// The upper limit of the joint. When the joint angle or position is above it, 
	CSRAW public float max { get { return m_Max; } set { m_Max = value; } }

	// The bounciness of the joint when hitting the upper limit of the joint.
	CSRAW public float maxBounce { get { return m_MaxBounce; } set { m_MaxBounce = value; } }
END


C++RAW

struct MonoJointMotor
{
	float targetVelocity;
	float force;
	short freeSpin;// bool's need to be shorts in mono but in novodex bools are ints

	MonoJointMotor (const JointMotor& motor)
	{
		targetVelocity = motor.targetVelocity;
		force = motor.force;
		freeSpin = motor.freeSpin;
	}

	operator JointMotor () const
	{
		JointMotor motor;
		motor.targetVelocity = targetVelocity;
		motor.force = force;
		motor.freeSpin = freeSpin;
		return motor;
	}
};



// Joint is the base class for all joints.
CONDITIONAL ENABLE_PHYSICS
NONSEALED_CLASS Joint : Component

	// A reference to another rigidbody this joint connects to.
	AUTO_PTR_PROP Rigidbody connectedBody GetConnectedBody SetConnectedBody

	// The Direction of the axis around which the body is constrained.
	AUTO_PROP Vector3 axis GetAxis SetAxis

	// The Position of the anchor around which the joints motion is constrained.
	AUTO_PROP Vector3 anchor GetAnchor SetAnchor

	// The force that needs to be applied for this joint to break.
	AUTO_PROP float breakForce GetBreakForce SetBreakForce

	// The torque that needs to be applied for this joint to break.
	AUTO_PROP float breakTorque GetBreakTorque SetBreakTorque
	
	// Called when a joint attached to the same game object broke.
	CSNONE void OnJointBreak (float breakForce);
END

// The HingeJoint groups together 2 rigid bodies, constraining them to move like connected by a hinge.
CONDITIONAL ENABLE_PHYSICS
CLASS HingeJoint : Joint

	// Setting the motor, limit, spring automatically enabled them.
	
	// The motor will apply a force up to a maximum force to achieve the target velocity in degrees per second.
	AUTO_PROP JointMotor motor GetMotor SetMotor
	
	// The limits of the hinge joint.
	AUTO_PROP JointLimits limits GetLimits SetLimits
	
	// The spring attempts to reach a target angle by adding spring and damping forces.
	AUTO_PROP JointSpring spring GetSpring SetSpring
	
	// Enables the joint's motor.
	AUTO_PROP bool useMotor GetUseMotor SetUseMotor

	// Enables the joint's limits.
	AUTO_PROP bool useLimits GetUseLimits SetUseLimits

	// Enables the joint's spring.
	AUTO_PROP bool useSpring GetUseSpring SetUseSpring
	
	// The angular velocity of the joint in degrees per second.
	AUTO_PROP float velocity GetVelocity
	
	// The current angle in degrees of the joint relative to its rest position. (RO)
	AUTO_PROP float angle GetAngle
END



// The spring joint ties together 2 rigid bodies, spring forces will be automatically applied to keep the object at the given distance.
CONDITIONAL ENABLE_PHYSICS
CLASS SpringJoint : Joint

	// The spring force used to keep the two objects together
	AUTO_PROP float spring GetSpring SetSpring
	// The damper force used to dampen the spring force
	AUTO_PROP float damper GetDamper SetDamper

	// The minimum distance between the bodies relative to their initial distance
	AUTO_PROP float minDistance GetMinDistance SetMinDistance

	// The maximum distance between the bodies relative to their initial distance
	AUTO_PROP float maxDistance GetMaxDistance SetMaxDistance
END

// The Fixed joint groups together 2 rigidbodies, making them stick together in their bound position.
CONDITIONAL ENABLE_PHYSICS
CLASS FixedJoint : Joint

END

// The limits defined by the [[CharacterJoint]]
CONDITIONAL ENABLE_PHYSICS
STRUCT SoftJointLimit
	CSRAW float m_Limit;
	CSRAW float m_Bounciness;
	CSRAW float m_Spring;
	CSRAW float m_Damper;
	
	// The limit position/angle of the joint.
	CSRAW public float limit { get { return m_Limit; } set { m_Limit = value; } }

	// If greater than zero, the limit is soft. The spring will pull the joint back.
	CSRAW public float spring { get { return m_Spring; } set { m_Spring = value; } }

	// If spring is greater than zero, the limit is soft.
	CSRAW public float damper { get { return m_Damper; } set { m_Damper = value; } }

	// When the joint hits the limit, it can be made to bounce off it.
	CSRAW public float bounciness { get { return m_Bounciness; } set { m_Bounciness = value; } }
	
	OBSOLETE error Use SoftJointLimit.bounciness instead
	CSRAW public float bouncyness { get { return m_Bounciness; } set { m_Bounciness = value; } }
END


// The [[ConfigurableJoint]] attempts to attain position / velocity targets based on this flag
CSRAW [Flags]
ENUM JointDriveMode
	// Don't apply any forces to reach the target
	None = 0,
	// Try to reach the specified target position
	Position = 1,
	// Try to reach the specified target velocity
	Velocity = 2,
	// Try to reach the specified target position and velocity
	PositionAndVelocity = 3
END

// Determines how to snap physics joints back to its constrained position when it drifts off too much
ENUM JointProjectionMode
	// Don't snap at all
	None = 0,
	// Snap both position and rotation
	PositionAndRotation = 1,
	// Snap Position only
	PositionOnly = 2
END

// How the joint's movement will behave along its local X axis
CONDITIONAL ENABLE_PHYSICS
STRUCT JointDrive
	CSRAW int    m_Mode;
	CSRAW float m_PositionSpring;
	CSRAW float m_PositionDamper;
	CSRAW float m_MaximumForce;
	
	// Whether the drive should attempt to reach position, velocity, both or nothing
	CSRAW public JointDriveMode mode { get { return (JointDriveMode)m_Mode; } set { m_Mode = (int)value; } }

	// Strength of a rubber-band pull toward the defined direction. Only used if /mode/ includes Position.
	CSRAW public float positionSpring { get { return m_PositionSpring; } set { m_PositionSpring = value; } }

	// Resistance strength against the Position Spring. Only used if /mode/ includes Position.
	CSRAW public float positionDamper { get { return m_PositionDamper; } set { m_PositionDamper = value; } }

	// Amount of force applied to push the object toward the defined direction.
	CSRAW public float maximumForce { get { return m_MaximumForce; } set { m_MaximumForce = value; } }
END

// Character Joints are mainly used for Ragdoll effects. They are an extended ball-socket joint which allows you to limit the joint on each axis.
CONDITIONAL ENABLE_PHYSICS
CLASS CharacterJoint : Joint

	// The secondary axis around which the joint can rotate
	AUTO_PROP Vector3 swingAxis GetSwingAxis SetSwingAxis

	// The lower limit around the primary axis of the character joint.
	AUTO_PROP SoftJointLimit lowTwistLimit GetLowTwistLimit SetLowTwistLimit

	// The upper limit around the primary axis of the character joint.
	AUTO_PROP SoftJointLimit highTwistLimit GetHighTwistLimit SetHighTwistLimit
	
	// The limit around the primary axis of the character joint.
	AUTO_PROP SoftJointLimit swing1Limit GetSwing1Limit SetSwing1Limit

	// The limit around the primary axis of the character joint.
	AUTO_PROP SoftJointLimit swing2Limit GetSwing2Limit SetSwing2Limit
	
	//*undocumented*
	AUTO_PROP Quaternion targetRotation GetTargetRotation SetTargetRotation 
	//*undocumented*
	AUTO_PROP Vector3 targetAngularVelocity GetTargetAngularVelocity SetTargetAngularVelocity
	//*undocumented*
	AUTO_PROP JointDrive rotationDrive GetRotationDrive SetRotationDrive

END

// Constrains movement for a [[ConfigurableJoint]] along the 6 axes.
ENUM ConfigurableJointMotion 
	// Motion along the axis will be locked
	Locked = 0,
	// Motion along the axis will be limited by the respective limit
	Limited = 1,
	// Motion along the axis will be completely free and completely unconstrained
	Free = 2
END

// Control [[ConfigurableJoint]]'s rotation with either X & YZ or Slerp Drive
ENUM RotationDriveMode 
	// Use XY & Z Drive
	XYAndZ = 0,
	// Use Slerp drive
	Slerp = 1
END

// The configurable joint is an extremely flexible joint giving you complete control over rotation and linear motion.
CONDITIONAL ENABLE_PHYSICS
CLASS ConfigurableJoint : Joint

	// The joint's secondary axis.	
	AUTO_PROP Vector3 secondaryAxis GetSecondaryAxis SetSecondaryAxis

	// Allow movement along the X axis to be Free, completely Locked, or Limited according to Linear Limit	
	AUTO_PROP ConfigurableJointMotion xMotion GetXMotion SetXMotion
	// Allow movement along the Y axis to be Free, completely Locked, or Limited according to Linear Limit
	AUTO_PROP ConfigurableJointMotion yMotion GetYMotion SetYMotion
	// Allow movement along the Z axis to be Free, completely Locked, or Limited according to Linear Limit
	AUTO_PROP ConfigurableJointMotion zMotion GetZMotion SetZMotion

	// Allow rotation around the X axis to be Free, completely Locked, or Limited according to Low and High Angular XLimit
	AUTO_PROP ConfigurableJointMotion angularXMotion GetAngularXMotion SetAngularXMotion
	// Allow rotation around the Y axis to be Free, completely Locked, or Limited according to Angular YLimit
	AUTO_PROP ConfigurableJointMotion angularYMotion GetAngularYMotion SetAngularYMotion
	// Allow rotation around the Z axis to be Free, completely Locked, or Limited according to Angular ZLimit
	AUTO_PROP ConfigurableJointMotion angularZMotion GetAngularZMotion SetAngularZMotion

	// Boundary defining movement restriction, based on distance from the joint's origin
	AUTO_PROP SoftJointLimit linearLimit GetLinearLimit SetLinearLimit

	// Boundary defining lower rotation restriction, based on delta from original rotation
	AUTO_PROP SoftJointLimit lowAngularXLimit GetLowAngularXLimit SetLowAngularXLimit

	// Boundary defining upper rotation restriction, based on delta from original rotation.
	AUTO_PROP SoftJointLimit highAngularXLimit GetHighAngularXLimit SetHighAngularXLimit

	// Boundary defining rotation restriction, based on delta from original rotation
	AUTO_PROP SoftJointLimit angularYLimit GetAngularYLimit SetAngularYLimit

	// Boundary defining rotation restriction, based on delta from original rotation
	AUTO_PROP SoftJointLimit angularZLimit GetAngularZLimit SetAngularZLimit

	// The desired position that the joint should move into
	AUTO_PROP Vector3 targetPosition GetTargetPosition SetTargetPosition
	// The desired velocity that the joint should move along
	AUTO_PROP Vector3 targetVelocity GetTargetVelocity SetTargetVelocity

	// Definition of how the joint's movement will behave along its local X axis
	AUTO_PROP JointDrive xDrive GetXDrive SetXDrive

	// Definition of how the joint's movement will behave along its local Y axis
	AUTO_PROP JointDrive yDrive GetYDrive SetYDrive

	// Definition of how the joint's movement will behave along its local Z axis
	AUTO_PROP JointDrive zDrive GetZDrive SetZDrive

	// This is a [[Quaternion]]. It defines the desired rotation that the joint should rotate into.
	AUTO_PROP Quaternion targetRotation GetTargetRotation SetTargetRotation
	// This is a [[Vector3]]. It defines the desired angular velocity that the joint should rotate into.
	AUTO_PROP Vector3 targetAngularVelocity GetTargetAngularVelocity SetTargetAngularVelocity
	// Control the object's rotation with either X & YZ or Slerp Drive by itself
	AUTO_PROP RotationDriveMode rotationDriveMode GetRotationDriveMode SetRotationDriveMode

	// Definition of how the joint's rotation will behave around its local X axis. Only used if Rotation Drive Mode is Swing & Twist
	AUTO_PROP JointDrive angularXDrive GetAngularXDrive SetAngularXDrive
	
	// Definition of how the joint's rotation will behave around its local Y and Z axes. Only used if Rotation Drive Mode is Swing & Twist
	AUTO_PROP JointDrive angularYZDrive GetAngularYZDrive SetAngularYZDrive

	// Definition of how the joint's rotation will behave around all local axes. Only used if Rotation Drive Mode is Slerp Only
	AUTO_PROP JointDrive slerpDrive GetSlerpDrive SetSlerpDrive
	

	// Properties to track to snap the object back to its constrained position when it drifts off too much
	AUTO_PROP JointProjectionMode projectionMode GetProjectionMode SetProjectionMode
	
	// Distance from the Connected Body that must be exceeded before the object snaps back to an acceptable position
	AUTO_PROP float projectionDistance GetProjectionDistance SetProjectionDistance 	

	// Difference in angle from the Connected Body that must be exceeded before the object snaps back to an acceptable position
	AUTO_PROP float projectionAngle GetProjectionAngle SetProjectionAngle 	


	// If enabled, all Target values will be calculated in world space instead of the object's local space
	AUTO_PROP bool configuredInWorldSpace GetConfiguredInWorldSpace SetConfiguredInWorldSpace

	// If enabled, the two connected rigidbodies will be swapped, as if the joint was attached to the other body.
	AUTO_PROP bool swapBodies GetSwapBodies SetSwapBodies

END


// A force applied constantly.
CONDITIONAL ENABLE_PHYSICS
CLASS ConstantForce : Behaviour
	// The force applied to the rigidbody every frame.
	CUSTOM_PROP Vector3 force { return self->m_Force; } { self->m_Force = value; }

	// The force - relative to the rigid bodies coordinate system - applied every frame.
	CUSTOM_PROP Vector3 relativeForce { return self->m_RelativeForce; } { self->m_RelativeForce = value; }

	// The torque applied to the rigidbody every frame.
	CUSTOM_PROP Vector3 torque { return self->m_Torque; } { self->m_Torque = value; }
	
	// The torque - relative to the rigid bodies coordinate system - applied every frame.
	CUSTOM_PROP Vector3 relativeTorque { return self->m_RelativeTorque; } { self->m_RelativeTorque = value; }
END

// The collision detection mode constants used for [[Rigidbody.collisionDetectionMode]].
ENUM CollisionDetectionMode
	// Continuous collision detection is off for this Rigidbody. 
	Discrete = 0,
	// Continuous collision detection is on for colliding with static mesh geometry.
	Continuous = 1,
	// Continuous collision detection is on for colliding with static and dynamic geometry.
	ContinuousDynamic = 2
END

// A base class of all colliders.
CONDITIONAL ENABLE_PHYSICS
NONSEALED_CLASS Collider : Component
	// Enabled Colliders will collide with other colliders, disabled Colliders won't.
	AUTO_PROP bool enabled GetEnabled SetEnabled

	// The rigidbody the collider is attached to.
	AUTO_PTR_PROP Rigidbody attachedRigidbody GetRigidbody

	// Is the collider a trigger?
	AUTO_PROP bool isTrigger GetIsTrigger SetIsTrigger

	// The material used by the collider.
	CUSTOM_PROP PhysicMaterial material
	{
		PhysicMaterial* material = self->GetMaterial ();
		PhysicMaterial* instance = &PhysicMaterial::GetInstantiatedMaterial (material, *self);
		if (instance != material)
			self->SetMaterial (instance);
		return Scripting::ScriptingWrapperFor (instance);
	}
	{
		self->SetMaterial (value);
	}
	
	// The closest point to the bounding box of the attached collider.
	CUSTOM Vector3 ClosestPointOnBounds (Vector3 position)
	{
		float dist; Vector3f outpos;
		self->ClosestPointOnBounds(position, outpos, dist);
		return outpos;
	}
	
	// The shared physic material of this collider.
	CUSTOM_PROP PhysicMaterial sharedMaterial { return Scripting::ScriptingWrapperFor (self->GetMaterial ()); } { self->SetMaterial (value); }
	
	// The world space bounding volume of the collider.
	AUTO_PROP Bounds bounds GetBounds

	CUSTOM private static bool Internal_Raycast (Collider col, Ray ray, out RaycastHit hitInfo, float distance)
	{
		hitInfo->collider = NULL;

		bool didHit = col->Raycast (ray, distance, *hitInfo);
		if (didHit)
		{
		#if PLATFORM_WINRT
			hitInfo->collider = reinterpret_cast<Collider*> (ScriptingGetObjectReference((Collider*)col));
		#else
			hitInfo->collider = reinterpret_cast<Collider*> (col.GetScriptingObject());
		#endif
			return true;
		}
		else
		{
			return false;
		}
	}
	
	// Casts a [[Ray]] that ignores all Colliders except this one.

	CSRAW public bool Raycast (Ray ray, out RaycastHit hitInfo, float distance)
	{
		return Internal_Raycast (this, ray, out hitInfo, distance);
	}

	// OnTriggerEnter is called when the [[Collider]] /other/ enters the [[class-BoxCollider|trigger]].
	CSNONE void OnTriggerEnter (Collider other);

	// OnTriggerExit is called when the [[Collider]] /other/ has stopped touching the [[class-BoxCollider|trigger]].
	CSNONE void OnTriggerExit (Collider other);

	// OnTriggerStay is called ''almost'' all the frames for every [[Collider]] __other__ that is touching the [[class-BoxCollider|trigger]].
	CSNONE void OnTriggerStay (Collider other);

	// OnCollisionEnter is called when this collider/rigidbody has begun touching another rigidbody/collider.

	CSNONE void OnCollisionEnter (Collision collisionInfo);

	// OnCollisionExit is called when this collider/rigidbody has stopped touching another rigidbody/collider.
	CSNONE void OnCollisionExit (Collision collisionInfo);

	// OnCollisionStay is called once per frame for every collider/rigidbody that is touching rigidbody/collider.
	CSNONE void OnCollisionStay (Collision collisionInfo);
END

// A box-shaped primitive collider.
CONDITIONAL ENABLE_PHYSICS
CLASS BoxCollider : Collider
	// The center of the box, measured in the object's local space.
	AUTO_PROP Vector3 center GetCenter SetCenter

	// The size of the box, measured in the object's local space.
	AUTO_PROP Vector3 size GetSize SetSize

	//*undocumented* DEPRECATED
	OBSOLETE warning use BoxCollider.size instead.
	CSRAW public Vector3 extents { get { return size * 0.5F; }  set { size = value * 2.0F; } }
END


// A sphere-shaped primitive collider.
CONDITIONAL ENABLE_PHYSICS
CLASS SphereCollider : Collider
	// The center of the sphere, measured in the object's local space.
	AUTO_PROP Vector3 center GetCenter SetCenter

	// The radius of the sphere, measured in the object's local space.
	AUTO_PROP float radius GetRadius SetRadius
END

// A mesh collider allows you to do [[wiki:class-MeshCollider|collision detection]] between meshes and primitives.
CONDITIONAL ENABLE_PHYSICS
CLASS MeshCollider : Collider
	//*undocumented* deprecated with version 1.5 (should implement modifiable mesh interface)
	OBSOLETE warning mesh has been replaced with sharedMesh and will be deprecated
	CSRAW public Mesh mesh { get { return sharedMesh; } set { sharedMesh = value; }  }

	// The mesh object used for collision detection
	AUTO_PTR_PROP Mesh sharedMesh GetSharedMesh SetSharedMesh
	
	// Use a convex collider from the mesh.
	AUTO_PROP bool convex GetConvex SetConvex
	
	// Uses interpolated normals for sphere collisions instead of flat polygonal normals.
	AUTO_PROP bool smoothSphereCollisions GetSmoothSphereCollisions SetSmoothSphereCollisions
	
END

// A capsule-shaped primitive collider.
CONDITIONAL ENABLE_PHYSICS
CLASS CapsuleCollider : Collider
	// The center of the capsule, measured in the object's local space. 
	AUTO_PROP Vector3 center GetCenter SetCenter

	// The radius of the sphere, measured in the object's local space.
	AUTO_PROP float radius GetRadius SetRadius

	// The height of the capsule meased in the object's local space.
	AUTO_PROP float height GetHeight SetHeight

	// The direction of the capsule.
	AUTO_PROP int direction GetDirection SetDirection

END

OBSOLETE warning Use WheelCollider or BoxCollider instead, RaycastCollider is unreliable
CONDITIONAL ENABLE_PHYSICS
CLASS RaycastCollider : Collider
	OBSOLETE warning Use WheelCollider or BoxCollider instead, RaycastCollider is unreliable
	AUTO_PROP Vector3 center GetCenter SetCenter
	
	OBSOLETE warning Use WheelCollider or BoxCollider instead, RaycastCollider is unreliable
	AUTO_PROP float length GetLength SetLength
END


// WheelFrictionCurve is used by the [[WheelCollider]] to describe friction properties of the wheel tire.
CONDITIONAL ENABLE_PHYSICS
STRUCT WheelFrictionCurve
	CSRAW private float m_ExtremumSlip;
	CSRAW private float m_ExtremumValue;
	CSRAW private float m_AsymptoteSlip;
	CSRAW private float m_AsymptoteValue;
	CSRAW private float m_Stiffness;
	
	// Extremum point slip (default 1).
	CSRAW public float extremumSlip { get { return m_ExtremumSlip; } set { m_ExtremumSlip = value; } }
	// Force at the extremum slip (default 20000).
	CSRAW public float extremumValue { get { return m_ExtremumValue; } set { m_ExtremumValue = value; } }
	// Asymptote point slip (default 2).
	CSRAW public float asymptoteSlip { get { return m_AsymptoteSlip; } set { m_AsymptoteSlip = value; } }
	// Force at the asymptote slip (default 10000).
	CSRAW public float asymptoteValue { get { return m_AsymptoteValue; } set { m_AsymptoteValue = value; } }
	// Multiplier for the ::ref::extremumValue and ::ref::asymptoteValue values (default 1).
	CSRAW public float stiffness { get { return m_Stiffness; } set { m_Stiffness = value; } }
END


// Contact information for the wheel, reported by [[WheelCollider]].
CONDITIONAL ENABLE_PHYSICS
STRUCT WheelHit
	CSRAW private Vector3	m_Point;
	CSRAW private Vector3	m_Normal;
	CSRAW private Vector3	m_ForwardDir;
	CSRAW private Vector3	m_SidewaysDir;
	CSRAW private float		m_Force;
	CSRAW private float		m_ForwardSlip;
	CSRAW private float		m_SidewaysSlip;
	CSRAW private Collider	m_Collider;
	
	// The other [[Collider]] the wheel is hitting.
	CSRAW public Collider	collider { get { return m_Collider; }  set { m_Collider = value; } }
	
	// The point of contact between the wheel and the ground.
	CSRAW public Vector3	point { get { return m_Point; } set { m_Point = value; } }
	// The normal at the point of contact.
	CSRAW public Vector3	normal { get { return m_Normal; } set { m_Normal = value; } }
	// The direction the wheel is pointing in.
	CSRAW public Vector3	forwardDir { get { return m_ForwardDir; } set { m_ForwardDir = value; } }
	// The sideways direction of the wheel.
	CSRAW public Vector3	sidewaysDir { get { return m_SidewaysDir; } set { m_SidewaysDir = value; } }
	
	// The magnitude of the force being applied for the contact.
	CSRAW public float		force { get { return m_Force; } set { m_Force = value; } }
	
	// Tire slip in the rolling direction. Acceleration slip is negative, braking slip is positive.
	CSRAW public float		forwardSlip { get { return m_ForwardSlip; } set { m_Force = m_ForwardSlip; } }
	
	// Tire slip in the sideways direction.
	CSRAW public float		sidewaysSlip { get { return m_SidewaysSlip; } set { m_SidewaysSlip = value; } }
END



// A special collider for vehicle wheels.
CONDITIONAL ENABLE_PHYSICS
CLASS WheelCollider : Collider
	// The center of the wheel, measured in the object's local space.
	AUTO_PROP Vector3 center GetCenter SetCenter
	
	// The radius of the wheel, measured in local space.
	AUTO_PROP float radius GetRadius SetRadius
	
	// Maximum extension distance of wheel suspension, measured in local space.
	AUTO_PROP float suspensionDistance GetSuspensionDistance SetSuspensionDistance
		
	// The parameters of wheel's suspension. The suspension attempts to reach a target position
	AUTO_PROP JointSpring suspensionSpring GetSuspensionSpring SetSuspensionSpring
	
	// The mass of the wheel. Must be larger than zero.
	AUTO_PROP float mass GetMass SetMass
	
	// Properties of tire friction in the direction the wheel is pointing in.
	AUTO_PROP WheelFrictionCurve forwardFriction GetForwardFriction SetForwardFriction
	
	// Properties of tire friction in the sideways direction.
	AUTO_PROP WheelFrictionCurve sidewaysFriction GetSidewaysFriction SetSidewaysFriction
	
	// Motor torque on the wheel axle. Positive or negative depending on direction.
	AUTO_PROP float motorTorque GetMotorTorque SetMotorTorque

	// Brake torque. Must be positive.
	AUTO_PROP float brakeTorque GetBrakeTorque SetBrakeTorque
	
	// Steering angle in degrees, always around the local y-axis.
	AUTO_PROP float steerAngle GetSteerAngle SetSteerAngle
	
	
	// Indicates whether the wheel currently collides with something (RO).
	AUTO_PROP bool isGrounded IsGrounded
	
	C++RAW

	struct MonoWheelHit
	{
		Vector3f	point;
		Vector3f	normal;
		Vector3f	forwardDir;
		Vector3f	sidewaysDir;
		float		force;
		float		forwardSlip;
		float		sidewaysSlip;
		ScriptingObjectPtr	collider;
	};

	
	// Gets ground collision data for the wheel.
	CUSTOM public bool GetGroundHit (out WheelHit hit)
	{
		WheelHit col;
		bool didHit = self->GetGroundHit( col );
		if( didHit )
		{
			hit->point = col.point;
			hit->normal = col.normal;
			hit->forwardDir = col.forwardDir;
			hit->sidewaysDir = col.sidewaysDir;
			hit->force = col.force;
			hit->forwardSlip = col.forwardSlip;
			hit->sidewaysSlip = col.sidewaysSlip;
			hit->collider = Scripting::ScriptingWrapperFor( col.collider );
			return true;
		}
		return false;
	}
	
	// Current wheel axle rotation speed, in rotations per minute (RO).
	AUTO_PROP float rpm GetRpm
END


// Structure used to get information back from a raycast.
CONDITIONAL ENABLE_PHYSICS
STRUCT RaycastHit
	CSRAW private Vector3   m_Point;
	CSRAW private Vector3   m_Normal;
	CSRAW private int       m_FaceID;
	CSRAW private float     m_Distance;
	CSRAW private Vector2   m_UV;
	#if PLATFORM_WINRT
	CSRAW private int		m_ColliderHandle;
	#else
	CSRAW private Collider	m_Collider;
	#endif
	
	// The impact point in world space where the ray hit the collider.
	CSRAW public Vector3 point { get { return m_Point; } set { m_Point = value; } }
	
	// The normal of the surface the ray hit.
	CSRAW public Vector3  normal { get { return m_Normal; } set { m_Normal = value; } }

	// The barycentric coordinate of the triangle we hit.
	CSRAW public Vector3 barycentricCoordinate { get { return new Vector3 (1.0F - (m_UV.y + m_UV.x), m_UV.x, m_UV.y); } set { m_UV = value; } }
	
	// The distance from the ray's origin to the impact point.
	CSRAW public float    distance { get { return m_Distance; } set { m_Distance = value; } }

	// The index of the triangle that was hit.
	CSRAW public int    triangleIndex { get { return m_FaceID; }  }
	
	// Workaround for gcc/msvc gcc where passing small mono structures by value does not work
	CUSTOM private static void CalculateRaycastTexCoord (out Vector2 output, Collider col, Vector2 uv, Vector3 point, int face, int index)
	{
		*output = CalculateRaycastTexcoord(col, uv, point, face, index);
	}
	
	// The uv texture coordinate at the impact point.
	CSRAW public Vector2 textureCoord { get { Vector2 coord; CalculateRaycastTexCoord(out coord, collider, m_UV, m_Point, m_FaceID, 0); return coord;  } }
	
	// The secondary uv texture coordinate at the impact point.
	CSRAW public Vector2 textureCoord2 { get { Vector2 coord; CalculateRaycastTexCoord(out coord, collider, m_UV, m_Point, m_FaceID, 1); return coord;  } }
	
	OBSOLETE warning Use textureCoord2 instead
	CSRAW public Vector2 textureCoord1 { get { Vector2 coord; CalculateRaycastTexCoord(out coord, collider, m_UV, m_Point, m_FaceID, 1); return coord;  } }
	
	// The uv lightmap coordinate at the impact point.
	CSRAW public Vector2 lightmapCoord { get {
		Vector2 coord;
		CalculateRaycastTexCoord(out coord, collider, m_UV, m_Point, m_FaceID, 1);
		if( collider.renderer != null )
		{
			Vector4 st = collider.renderer.lightmapTilingOffset;
			coord.x = coord.x * st.x + st.z;
			coord.y = coord.y * st.y + st.w;
		}
		return coord;  
	} }
	
	// The [[Collider]] that was hit.
	CONDITIONAL !PLATFORM_WINRT
	CSRAW public Collider collider { get { return m_Collider; }   }
	
	CONDITIONAL PLATFORM_WINRT
	CSRAW public Collider collider { get { return UnityEngineInternal.ScriptingUtils.GCHandleToObject<Collider>(m_ColliderHandle); }   }

	// The [[Rigidbody]] of the collider that was hit. If the collider is not attached to a rigidbody then it is /null/.
	CSRAW public Rigidbody rigidbody { get { return collider != null ? collider.attachedRigidbody : null; }  }
	
	// The [[Transform]] of the rigidbody or collider that was hit.
	CSRAW public Transform transform { get {
		Rigidbody body = rigidbody;
		if (body != null)
			return body.transform;
		else if (collider != null)
			return collider.transform;
		else
			return null;
	} }
END

// Describes how physic materials of colliding objects are combined.
ENUM PhysicMaterialCombine 
	// Averages the friction/bounce of the two colliding materials.
	Average = 0, 
	// Multiplies the friction/bounce of the two colliding materials.
	Multiply = 1, 
	// Uses the smaller friction/bounce of the two colliding materials.
	Minimum = 2,
	// Uses the larger friction/bounce of the two colliding materials.
	Maximum = 3 
END

// Physics material describes how to handle colliding objects (friction, bounciness).
CONDITIONAL ENABLE_PHYSICS
CLASS PhysicMaterial : Object

	CUSTOM private static void Internal_CreateDynamicsMaterial ([Writable]PhysicMaterial mat, string name)
	{
		PhysicMaterial* material = NEW_OBJECT (PhysicMaterial);
		SmartResetObject(*material);
		material->SetNameCpp (name);
		ConnectScriptingWrapperToObject (mat.GetScriptingObject(), material);
	}
	
	// Creates a new material.
	CSRAW public PhysicMaterial () { Internal_CreateDynamicsMaterial (this,null); }

	// Creates a new material named /name/.
	CSRAW public PhysicMaterial (string name){ Internal_CreateDynamicsMaterial (this,name); }

	// The friction used when already moving.  This value has to be between 0 and 1.
	AUTO_PROP float dynamicFriction GetDynamicFriction SetDynamicFriction

	// The friction used when an object is lying on a surface. Usually a value from 0 to 1.
	AUTO_PROP float staticFriction GetStaticFriction SetStaticFriction

	//  How bouncy is the surface? A value of 0 will not bounce. A value of 1 will bounce without any loss of energy.
	AUTO_PROP float bounciness GetBounciness SetBounciness
	
	OBSOLETE error Use PhysicMaterial.bounciness instead
	CSRAW public float bouncyness { get { return bounciness; } set { bounciness = value;} }
	
	// The direction of anisotropy. Anisotropic friction is enabled if the vector is not zero.
	AUTO_PROP Vector3 frictionDirection2 GetFrictionDirection2 SetFrictionDirection2

	// If anisotropic friction is enabled, dynamicFriction2 will be applied along frictionDirection2.
	AUTO_PROP float dynamicFriction2 GetDynamicFriction2 SetDynamicFriction2

	// If anisotropic friction is enabled, staticFriction2 will be applied along frictionDirection2.
	AUTO_PROP float staticFriction2 GetStaticFriction2 SetStaticFriction2

	// Determines how the friction is combined.
	AUTO_PROP PhysicMaterialCombine frictionCombine GetFrictionCombine SetFrictionCombine

	// Determines how the bounciness is combined.
	AUTO_PROP PhysicMaterialCombine bounceCombine GetBounceCombine SetBounceCombine
	
	//	*undocumented* DEPRECATED
	OBSOLETE warning use PhysicMaterial.frictionDirection2 instead.
	CSRAW public Vector3 frictionDirection { get { return frictionDirection2; }  set { frictionDirection2 = value; }}
END

// Describes a contact point where the collision occurs.
CONDITIONAL ENABLE_PHYSICS
STRUCT ContactPoint
	CSRAW internal Vector3  m_Point;
	CSRAW internal Vector3  m_Normal;
	CSRAW internal Collider m_ThisCollider;
	CSRAW internal Collider m_OtherCollider;

	// The point of contact.
	CSRAW public Vector3 point  { get { return m_Point; } }

	// Normal of the contact point.
	CSRAW public Vector3 normal { get { return m_Normal; } }

	// The first collider in contact.
	CSRAW public Collider thisCollider { get { return m_ThisCollider; } }

	// The other collider in contact.
	CSRAW public Collider otherCollider { get { return m_OtherCollider; } }
END

// Describes collision.
CSRAW [StructLayout (LayoutKind.Sequential)]
CONDITIONAL ENABLE_PHYSICS
NONSEALED_CLASS Collision
	CSRAW internal Vector3        m_RelativeVelocity;
	CSRAW internal Rigidbody      m_Rigidbody;
	CSRAW internal Collider       m_Collider;
	
	CSRAW internal ContactPoint[] m_Contacts;

	// The relative linear velocity of the two colliding objects (RO).
	CSRAW public Vector3 relativeVelocity { get { return m_RelativeVelocity; } }

	// The [[Rigidbody]] we hit (RO). This is /null/ if the object we hit is a collider with no rigidbody attached.
	CSRAW public Rigidbody rigidbody { get { return m_Rigidbody; } }

	// The [[Collider]] we hit (RO).
	CSRAW
	CSRAW public Collider collider { get { return m_Collider; } }

	// The [[Transform]] of the object we hit (RO).
	CSRAW public Transform transform { get { return rigidbody != null ? rigidbody.transform : collider.transform; } }

	// The [[GameObject]] whose collider we are colliding with. (RO).
	CSRAW public GameObject gameObject { get { return m_Rigidbody != null ? m_Rigidbody.gameObject : m_Collider.gameObject; } }

	// The contact points generated by the physics engine.

	CSRAW public ContactPoint[] contacts { get { return m_Contacts; } }

	//*undocumented*	
	CSRAW public virtual IEnumerator GetEnumerator ()
	{
		return contacts.GetEnumerator ();
	}

	//*undocumented* DEPRECATED
	OBSOLETE warning use Collision.relativeVelocity instead.
	CSRAW public Vector3 impactForceSum { get { return relativeVelocity; } }
	//*undocumented* DEPRECATED
	OBSOLETE warning will always return zero.
	CSRAW public Vector3 frictionForceSum { get { return Vector3.zero; } }

	OBSOLETE warning Please use Collision.rigidbody, Collision.transform or Collision.collider instead
	CSRAW public Component other { get { return m_Rigidbody != null ? (Component)m_Rigidbody : (Component)m_Collider; } }
END


// CollisionFlags is a bitmask returned by CharacterController.Move.
ENUM CollisionFlags
	// CollisionFlags is a bitmask returned by CharacterController.Move.
	None = 0,

	// CollisionFlags is a bitmask returned by CharacterController.Move.
	Sides = 1,
	
	// CollisionFlags is a bitmask returned by CharacterController.Move.
	Above = 2,
	
	// CollisionFlags is a bitmask returned by CharacterController.Move.
	Below = 4,
	
	//*undocumented
	CollidedSides = 1,
	//*undocumented
	CollidedAbove = 2,
	//*undocumented
	CollidedBelow = 4
END

// ControllerColliderHit is used by CharacterController.OnControllerColliderHit to give detailed information about the collision and how to deal with it.
CSRAW [StructLayout (LayoutKind.Sequential)]
CONDITIONAL ENABLE_PHYSICS
CLASS ControllerColliderHit
	CSRAW internal CharacterController m_Controller;
	CSRAW internal Collider            m_Collider;
	CSRAW internal Vector3             m_Point;
	CSRAW internal Vector3             m_Normal;
	CSRAW internal Vector3             m_MoveDirection;
	CSRAW internal float               m_MoveLength;
	CSRAW internal int                 m_Push;
	
	// The controller that hit the collider
	CSRAW public CharacterController controller { get { return m_Controller; } }

	// The collider that was hit by the controller
	CSRAW  public Collider collider { get { return m_Collider; } }

	// The rigidbody that was hit by the controller.
	CSRAW  public Rigidbody rigidbody { get { return m_Collider.attachedRigidbody; } }

	// The game object that was hit by the controller.
	CSRAW  public GameObject gameObject { get { return m_Collider.gameObject; } }

	// The transform that was hit by the controller.
	CSRAW  public Transform transform { get { return m_Collider.transform; } }
	
	// The impact point in world space.
	CSRAW public Vector3 point { get { return m_Point; } }

	// The normal of the surface we collided with in world space.
	CSRAW public Vector3 normal { get { return m_Normal; } }

	// Approximately the direction from the center of the capsule to the point we touch.
	CSRAW public Vector3 moveDirection { get { return m_MoveDirection; } }

	// How far the character has travelled until it hit the collider.
	CSRAW public float moveLength { get { return m_MoveLength; } }

	//*undocumented NOT IMPLEMENTED
	CSRAW private bool push { get { return m_Push != 0; } set { m_Push = value ? 1 : 0; } }


END


// A CharacterController allows you to easily do movement constrained by collisions without having to deal with a rigidbody.
CONDITIONAL ENABLE_PHYSICS
CLASS CharacterController : Collider
	
	// Moves the character with /speed/.
	AUTO bool SimpleMove (Vector3 speed);

	// A more complex move function taking absolute movement deltas.
	AUTO CollisionFlags Move (Vector3 motion);


	// Was the CharacterController touching the ground during the last move?
	AUTO_PROP bool isGrounded IsGrounded

	// The current relative velocity of the Character (see notes).
	AUTO_PROP Vector3 velocity GetVelocity


	// What part of the capsule collided with the environment during the last CharacterController.Move call.
	AUTO_PROP CollisionFlags collisionFlags GetCollisionFlags

	// The radius of the character's capsule
	AUTO_PROP float radius GetRadius SetRadius
	
	// The height of the character's capsule
	AUTO_PROP float height GetHeight SetHeight
		
	// The center of the character's capsule relative to the transform's position.
	AUTO_PROP Vector3 center GetCenter SetCenter	

	// The character controllers slope limit in degrees
	AUTO_PROP float slopeLimit GetSlopeLimit SetSlopeLimit

	// The character controllers step offset in meters
	AUTO_PROP float stepOffset GetStepOffset SetStepOffset

		
	// OnControllerColliderHit is called when the controller hits a collider while performing a Move.
	CSNONE void OnControllerColliderHit (ControllerColliderHit hit);


	// Determines whether other rigidbodies or character controllers collide with this character controller (by default this is always enabled).
	AUTO_PROP bool detectCollisions GetDetectCollisions SetDetectCollisions

END

CONDITIONAL ENABLE_CLOTH
// Base class used to simulate cloth physics - shared by both [[InteractiveCloth]] and [[SkinnedCloth]]
NONSEALED_CLASS Cloth : Component

	// Bending stiffness of the cloth.
	AUTO_PROP float bendingStiffness GetBendingStiffness SetBendingStiffness

	// Stretching stiffness of the cloth.
	AUTO_PROP float stretchingStiffness GetStretchingStiffness SetStretchingStiffness

	// Damp cloth motion.
	AUTO_PROP float damping GetDamping SetDamping

	// The thickness of the cloth surface.
	AUTO_PROP float thickness GetThickness SetThickness

	// A constant, external acceleration applied to the cloth.
	AUTO_PROP Vector3 externalAcceleration GetExternalAcceleration SetExternalAcceleration

	// A random, external acceleration applied to the cloth.
	AUTO_PROP Vector3 randomAcceleration GetRandomAcceleration SetRandomAcceleration
	
	// Should gravity affect the cloth simulation?
	AUTO_PROP bool useGravity GetUseGravity SetUseGravity

	// Will the cloth collide with itself?
	AUTO_PROP bool selfCollision GetSelfCollision SetSelfCollision
	
	// Is this cloth enabled?
	AUTO_PROP bool enabled GetEnabled SetEnabled
	
	// The current vertex positions of the cloth object.
	CUSTOM_PROP Vector3[] vertices
	{
		return CreateScriptingArray(&self->GetVertices()[0], self->GetVertices().size(), GetMonoManager().GetCommonClasses().vector3);
	}

	// The current normals of the cloth object.
	CUSTOM_PROP Vector3[] normals
	{
		return CreateScriptingArray(&self->GetNormals()[0], self->GetNormals().size(), GetMonoManager().GetCommonClasses().vector3);
	}
END

CONDITIONAL ENABLE_CLOTH
// The InteractiveCloth component is used to simulate objects with cloth physics.
CLASS InteractiveCloth : Cloth

	// The mesh used as base for the cloth object.
	AUTO_PTR_PROP Mesh mesh GetMesh SetMesh
	
	// The friction of the cloth.
	AUTO_PROP float friction GetFriction SetFriction
	
	// The density of the cloth.
	AUTO_PROP float density GetDensity SetDensity
	
	// The pressure inside the cloth.
	AUTO_PROP float pressure GetPressure SetPressure
	
	// How much force will be applied to colliding rigidbodies?
	AUTO_PROP float collisionResponse GetCollisionResponse SetCollisionResponse
	
	// How far cloth vertices need to be stretched, before the cloth will tear.
	AUTO_PROP float tearFactor GetTearFactor SetTearFactor	
		
	// How far attached rigid bodies need to be stretched, before they will tear off.
	AUTO_PROP float attachmentTearFactor GetAttachmentTearFactor SetAttachmentTearFactor

	// How much force will be applied to attached rigidbodies?
	AUTO_PROP float attachmentResponse GetAttachmentResponse SetAttachmentResponse
			
	// Did the cloth tear? (RO)
	AUTO_PROP bool isTeared GetIsTeared

	// Adds force /force/ to all vertices of the cloth mesh which are with /radius/ distance of /position/.
	CUSTOM void AddForceAtPosition (Vector3 force, Vector3 position, float radius, ForceMode mode = ForceMode.Force) { self->AddForceAtPosition (force, position, radius, mode); }
	
	// Attaches a /collider/ to the cloth object.
	CUSTOM void AttachToCollider (Collider collider, bool tearable = false, bool twoWayInteraction = false) { self->AttachToCollider (collider, tearable, twoWayInteraction); }
	
	// Detaches a /collider/ from the cloth object.
	CUSTOM void DetachFromCollider (Collider collider) { self->DetachFromCollider(collider); }
END

CONDITIONAL ENABLE_CLOTH
// The ClothSkinningCoefficient struct is used to set up how a [[SkinnedCloth]] component is allowed to move with respect to the [[SkinnedMeshRenderer]] it is attached to.
STRUCT ClothSkinningCoefficient
	//Distance a vertex is allowed to travel from the skinned mesh vertex position.
	CSRAW public float maxDistance;
	//Distorts the sphere defined by the maxDistance based on skinned mesh normals.
	CSRAW public float maxDistanceBias;
	//Definition of a sphere a vertex is not allowed to enter. This allows collision against the animated cloth.
	CSRAW public float collisionSphereRadius;
	//Definition of a sphere a vertex is not allowed to enter. This allows collision against the animated cloth.
	CSRAW public float collisionSphereDistance;
END

CONDITIONAL ENABLE_CLOTH
// The SkinnedCloth component works together with the [[SkinnedMeshRenderer]] to simulate clothing on a character.
CLASS SkinnedCloth : Cloth
	// The cloth skinning coefficients used to set up how the cloth interacts with the skinned mesh.
	CUSTOM_PROP ClothSkinningCoefficient[] coefficients
	{
#if !PLATFORM_WINRT
		return CreateScriptingArray(&self->GetCoefficients()[0], self->GetCoefficients().size(), GetMonoManager().GetBuiltinMonoClass("ClothSkinningCoefficient"));
#else
		return SCRIPTING_NULL;
#endif
	}
	{
#if !PLATFORM_WINRT
		int count = mono_array_length_safe(value);
		if (count == self->GetCoefficients().size())
			self->SetCoefficients(&GetMonoArrayElement<SkinnedCloth::ClothConstrainCoefficients> (value, 0));
		else
			ErrorString ("Number of coefficients must match number of vertices!");
#endif
	}

	// How much world-space movement of the character will affect cloth vertices.
	AUTO_PROP float worldVelocityScale GetWorldVelocityScale SetWorldVelocityScale

	// How much world-space acceleration of the character will affect cloth vertices.
	AUTO_PROP float worldAccelerationScale GetWorldAccelerationScale SetWorldAccelerationScale
	
	// Fade the cloth simulation in or out, and enabled or disable the SkinnedCloth.
	CUSTOM void SetEnabledFading (bool enabled, float interpolationTime = 0.5f) { self->SetEnabledFading (enabled, interpolationTime); }
END

CONDITIONAL ENABLE_CLOTH
// The ClothRenderer component is used together with the [[InteractiveCloth]] component, to visualize a cloth object in the scene.
CLASS ClothRenderer : Renderer
	// Pause the cloth simulation, when the ClothRenderer is not currently visible.
	AUTO_PROP bool pauseWhenNotVisible GetPauseWhenNotVisible SetPauseWhenNotVisible
END

CSRAW
}
#endif
