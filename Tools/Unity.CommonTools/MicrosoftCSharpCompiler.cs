using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace Unity.CommonTools
{
    public static class MicrosoftCSharpCompiler
    {
        private interface ICompilerOptions
        {
            IEnumerable<string> Options { get; }
            IEnumerable<string> Defines { get; }
            IEnumerable<string> References { get; }
            IEnumerable<string> CreateTempSourceFiles();
        }

        private sealed class WP8CompilerOptions : ICompilerOptions
        {
            public IEnumerable<string> Options { get; private set; }
            public IEnumerable<string> Defines { get; private set; }
            public IEnumerable<string> References { get; private set; }

            public WP8CompilerOptions()
            {
                Options = new[] { "/nologo", "/noconfig", "/nowarn:1701,1702,2008", "/nostdlib+", "/errorreport:prompt", "/warn:4", "/errorendlocation", "/preferreduilang:en-US", "/debug:pdbonly", "/optimize+", "/target:library", "/utf8output" };
                Defines = new[] { "SILVERLIGHT", "WINDOWS_PHONE" };
                var directory = Path.Combine(GetProgramFilesDirectory(), @"Reference Assemblies\Microsoft\Framework\WindowsPhone\v8.0");
                References = Directory.GetFiles(directory, "*.dll", SearchOption.TopDirectoryOnly);
            }

            public IEnumerable<string> CreateTempSourceFiles()
            {
                const string source =
@"// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(""WindowsPhone,Version=v8.0"", FrameworkDisplayName = ""Windows Phone 8.0"")]
";
                var path = Files.GetTempFile();
                File.WriteAllText(path, source);
                yield return path;
            }
        }

        private static string _windowsDirectory;
        private static string _programFilesDirectory;
        private static string _compilerPath;

        private static string GetWindowsDirectory()
        {
            if (_windowsDirectory == null)
            {
                var directory = Environment.GetEnvironmentVariable("windir");
                if (string.IsNullOrEmpty(directory))
                    directory = @"C:\Windows";
                if (!Directory.Exists(directory))
                    throw new Exception("Windows directory not found.");
                _windowsDirectory = directory;
            }
            return _windowsDirectory;
        }

        private static string GetProgramFilesDirectory()
        {
            if (_programFilesDirectory == null)
            {
                var directory = Environment.GetEnvironmentVariable("ProgramFiles(x86)");
                if (string.IsNullOrEmpty(directory))
                    directory = @"C:\Program Files (x86)";
                if (!Directory.Exists(directory))
                    throw new Exception("Program Files directory not found.");
                _programFilesDirectory = directory;
            }
            return _programFilesDirectory;
        }

        private static string GetCompilerPath()
        {
            if (_compilerPath == null)
            {
                var path = Path.Combine(GetWindowsDirectory(), @"Microsoft.NET\Framework\v4.0.30319\csc.exe");
                if (!File.Exists(path))
                    throw new Exception(".NET C# compiler not found.");
                _compilerPath = path;
            }
            return _compilerPath;
        }

        private static string BuildCompilerOptionString(ICompilerOptions options, IEnumerable<string> sourceFiles, string output, IEnumerable<string> additionalDefines)
        {
            var sb = new StringBuilder();

            foreach (var option in options.Options)
            {
                if (sb.Length > 0)
                    sb.Append(' ');
                sb.Append(option);
            }

            if (sb.Length > 0)
                sb.Append(' ');
            sb.Append("/out:\"");
            sb.Append(output);
            sb.Append('"');

            var defineSb = new StringBuilder();
            foreach (var define in options.Defines)
            {
                if (defineSb.Length > 0)
                    defineSb.Append(';');
                defineSb.Append(define);
            }
            if (additionalDefines != null)
            {
                foreach (var define in additionalDefines)
                {
                    if (defineSb.Length > 0)
                        defineSb.Append(';');
                    defineSb.Append(define);
                }
            }
            if (defineSb.Length > 0)
            {
                if (sb.Length > 0)
                    sb.Append(' ');
                sb.Append("/define:");
                sb.Append(defineSb);
            }

            foreach (var reference in options.References)
            {
                if (sb.Length > 0)
                    sb.Append(' ');
                sb.Append("/reference:\"");
                sb.Append(reference);
                sb.Append('"');
            }

            foreach (var sourceFile in sourceFiles)
            {
                if (sb.Length > 0)
                    sb.Append(' ');
                sb.Append('"');
                sb.Append(sourceFile);
                sb.Append('"');
            }

            return sb.ToString();
        }

        private static void Compile(ICompilerOptions options, string source, string output, IEnumerable<string> defines)
        {
            var sourceFiles = new List<string>();
            try
            {
                var command = GetCompilerPath();
                var sourceFile = Files.GetTempFile();
                File.WriteAllText(sourceFile, source);
                sourceFiles.Add(sourceFile);
                var tempSourceFiles = options.CreateTempSourceFiles();
                if (tempSourceFiles != null)
                    sourceFiles.AddRange(tempSourceFiles);
                var args = BuildCompilerOptionString(options, sourceFiles, output, defines);
                string error;
                int exitCode;
                var stdout = Shell.ExecuteProgramAndGetStdout(command, args, out error, out exitCode);
                if (exitCode != 0)
                    throw new Exception(string.Format("Failed to compile assembly \"{0}\":\r\n{1}", output, stdout));
            }
            finally
            {
                foreach (var sourceFile in sourceFiles)
                    File.Delete(sourceFile);
            }
        }

        public static void CompileWP8(string source, string output)
        {
            CompileWP8(source, output, null);
        }

        public static void CompileWP8(string source, string output, IEnumerable<string> defines)
        {
            Compile(new WP8CompilerOptions(), source, output, defines);
        }
    }
}
